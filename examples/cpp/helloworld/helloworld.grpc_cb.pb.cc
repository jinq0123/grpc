// Generated by the gRPC protobuf plugin.
// If you make any local change, they will be lost.
// source: helloworld.proto

#include "helloworld.grpc_cb.pb.h"

#include <google/protobuf/descriptor.h>
#include <google/protobuf/stubs/once.h>

#include <grpc_cb/channel.h>
#include <grpc_cb/completion_queue.h>
#include <grpc_cb/impl/call.h>

namespace helloworld {

namespace {
const ::google::protobuf::ServiceDescriptor* Greeter_descriptor = nullptr;
}  // namespace

void AssignDesc_helloworld_2eproto() {
  // Get the file's descriptor from the pool.
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "helloworld.proto");
  // Note that this GOOGLE_CHECK is necessary to prevent a warning about "file"
  // being unused when compiling an empty .proto file.
  GOOGLE_CHECK(file != NULL);
  Greeter_descriptor = file->service(0);
}  // AssignDesc_helloworld_2eproto()

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &AssignDesc_helloworld_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

}  // namespace

void ShutdownFile_helloworld_2eproto() {
}

void AddDesc_helloworld_2eproto() {
  // We don't need any special synchronization here because this code is
  // called at static init time before any threads exist.
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020helloworld.proto\022\nhelloworld\"\"\n\014HelloR"
    "equest\022\022\n\004name\030\001 \001(\tR\004name\"&\n\nHelloReply"
    "\022\030\n\007message\030\001 \001(\tR\007message2I\n\007Greeter\022>\n"
    "\010SayHello\022\030.helloworld.HelloRequest\032\026.he"
    "lloworld.HelloReply\"\000B\030\n\020io.grpc.example"
    "s\242\002\003HLWb\006proto3", 215);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "helloworld.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&ShutdownFile_helloworld_2eproto);
}
namespace Greeter {

static const ::google::protobuf::ServiceDescriptor* service_descriptor = nullptr;

static const char* method_names[] = {
  "/helloworld.Greeter/SayHello",
};

std::unique_ptr< Stub> NewStub(const ::grpc_cb::ChannelPtr& channel) {
  std::unique_ptr< Stub> stub(new Stub(channel));
  return stub;
}

Stub::Stub(const ::grpc_cb::ChannelPtr& channel)
  : ::grpc_cb::ServiceStub(channel)
    // , rpcmethod_SayHello_(method_names[0], ::grpc_cb::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc_cb::Status Stub::SayHello(
    const ::helloworld::HelloRequest& request,
    ::helloworld::HelloReply* response) {
  assert(response);
  ::grpc_cb::CompletionQueue cq;
  ::grpc_cb::CallUptr call(channel_->CreateCall(method_names[0], cq.cq()));
  void* tag = call.get();
  grpc_cb::Status status = call->StartBatch(request, tag);
  if (!status.ok()) return status;
  cq.Pluck(tag);
  return call->GetResponse(response);
}

void Stub::AsyncSayHello(
    const ::helloworld::HelloRequest& request,
    const SayHelloCallback& cb,
    const ::grpc_cb::ErrorCallback& err_cb) {
  assert(cb && err_cb && cq_);
  ::grpc_cb::CallUptr call(channel_->CreateCall(method_names[0], cq_->cq()));
  void* tag = call.get();
  grpc_cb::Status status = call->StartBatch(request, tag);
  if (!status.ok()) {
    err_cb(status);
  }
  call_map_[tag] = std::move(call);
}

// AsyncService::AsyncService() : ::grpc_cb::AsynchronousService(method_names, 1) {}

Service::Service() {
}

Service::~Service() {
}

::grpc_cb::Status Service::SayHello(const ::helloworld::HelloRequest& request, ::helloworld::HelloReply* response) {
  (void) request;
  (void) response;
  return ::grpc_cb::Status::UNIMPLEMENTED;
}

}  // namespace Greeter

}  // namespace helloworld

